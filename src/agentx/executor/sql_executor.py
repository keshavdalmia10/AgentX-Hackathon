"""
Multi-Dialect SQL Executor

Part of the AgentX Evaluation System. This executor:
1. Validates SQL queries against the database schema
2. Detects hallucinations (phantom tables, columns, functions)
3. Executes queries in a sandboxed environment
4. Returns detailed results for scoring

The executor receives SQL from external LLM agents and evaluates it.
It does NOT generate SQL - that's the job of the LLM being evaluated.

Supports: SQLite, DuckDB, PostgreSQL, BigQuery, Snowflake
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional
from datetime import datetime

from ..dialects import get_dialect_config, Dialect
from ..infrastructure import DatabaseAdapter, create_adapter, SchemaSnapshot
from ..validation import (
    MultiDialectSQLParser,
    HallucinationDetector,
    HallucinationReport,
    ValidationResult,
)


@dataclass
class ExecutorConfig:
    """Configuration for SQLExecutor."""
    dialect: str

    # For file-based databases (SQLite, DuckDB)
    db_path: Optional[str] = None

    # For server-based databases (PostgreSQL)
    connection_string: Optional[str] = None

    # For BigQuery
    project: Optional[str] = None
    dataset: Optional[str] = None

    # Execution settings
    row_limit: int = 1000
    timeout_seconds: float = 30.0
    validate_before_execute: bool = True

    def __post_init__(self):
        # Normalize dialect name
        self.dialect = self.dialect.lower()


@dataclass
class ExecutorResult:
    """
    Result from SQLExecutor.process_query().

    This format is compatible with the evaluation pipeline's
    AgentResult.from_agent_output() method.

    Contains:
    - query: Original SQL query
    - dialect: Database dialect used
    - validation: Validation results (is_valid, errors, warnings)
    - execution: Execution results (success, data, timing)
    - analysis: Additional analysis metadata
    - overall_status: "SUCCESS" or "FAILED"
    """
    query: str
    dialect: str
    timestamp: str = ""
    overall_status: str = "FAILED"

    validation: Dict[str, Any] = field(default_factory=dict)
    execution: Dict[str, Any] = field(default_factory=dict)
    analysis: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = datetime.utcnow().isoformat()

    @property
    def success(self) -> bool:
        return self.overall_status == "SUCCESS"

    @property
    def is_valid(self) -> bool:
        return self.validation.get("is_valid", False)

    @property
    def data(self) -> List[Dict[str, Any]]:
        return self.execution.get("data", [])

    @property
    def error(self) -> Optional[str]:
        return self.execution.get("error")

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format expected by evaluation pipeline."""
        return {
            "query": self.query,
            "dialect": self.dialect,
            "timestamp": self.timestamp,
            "overall_status": self.overall_status,
            "validation": self.validation,
            "execution": self.execution,
            "analysis": self.analysis,
        }


class SQLExecutor:
    """
    Multi-dialect SQL Executor for the evaluation system.

    This is the core component that:
    - Validates SQL queries generated by external LLM agents
    - Detects hallucinations (phantom tables, columns, functions)
    - Executes queries in a sandboxed environment
    - Returns detailed results for scoring

    Supported dialects:
    - sqlite (default, zero dependencies)
    - duckdb (pip install duckdb)
    - postgresql (pip install sqlalchemy psycopg2-binary)
    - bigquery (pip install google-cloud-bigquery)

    Example:
        # SQLite (in-memory, for testing)
        executor = SQLExecutor(ExecutorConfig(dialect="sqlite"))

        # DuckDB (analytics)
        executor = SQLExecutor(ExecutorConfig(dialect="duckdb", db_path="data.duckdb"))

        # PostgreSQL (production)
        executor = SQLExecutor(ExecutorConfig(
            dialect="postgresql",
            connection_string="postgresql://user:pass@localhost/db"
        ))

        # Evaluate a query
        result = executor.process_query("SELECT * FROM users")
        print(result.overall_status)  # "SUCCESS" or "FAILED"
    """

    def __init__(self, config: ExecutorConfig):
        """
        Initialize the SQL Executor.

        Args:
            config: Executor configuration with dialect and connection info
        """
        self.config = config
        self.dialect = config.dialect

        # Create database adapter
        self.adapter = self._create_adapter()
        self.adapter.connect()

        # Get schema snapshot
        self.schema = self.adapter.get_schema_snapshot()

        # Initialize validation components
        self.parser = MultiDialectSQLParser(default_dialect=self.dialect)
        self.detector = HallucinationDetector(dialect=self.dialect)

    def _create_adapter(self) -> DatabaseAdapter:
        """Create the appropriate database adapter."""
        return create_adapter(
            dialect=self.config.dialect,
            db_path=self.config.db_path,
            connection_string=self.config.connection_string,
        )

    def refresh_schema(self) -> SchemaSnapshot:
        """Refresh the schema snapshot from the database."""
        self.schema = self.adapter.get_schema_snapshot()
        return self.schema

    def validate_query(self, sql: str) -> ValidationResult:
        """
        Validate SQL query against the schema.

        Checks for:
        - Syntax errors
        - Phantom tables (hallucinations)
        - Phantom columns (hallucinations)
        - Invalid functions for the dialect

        Args:
            sql: SQL query to validate

        Returns:
            ValidationResult with errors, warnings, and hallucination report
        """
        return self.detector.validate(sql, self.schema, self.dialect)

    def execute_query(
        self,
        sql: str,
        limit: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Execute SQL query and return results.

        Args:
            sql: SQL query to execute
            limit: Override row limit (default from config)

        Returns:
            Dictionary with execution results
        """
        limit = limit or self.config.row_limit

        # Add LIMIT clause if not present and it's a SELECT
        parsed = self.parser.parse(sql, self.dialect)
        if parsed.is_select:
            sql = self._add_limit(sql, limit)

        result = self.adapter.execute(sql)

        return {
            "success": result.success,
            "data": result.data,
            "columns": result.columns,
            "rows_returned": result.rows_returned,
            "execution_time_ms": result.execution_time_ms,
            "error": result.error,
            "dialect": self.dialect,
        }

    def _add_limit(self, sql: str, limit: int) -> str:
        """Add LIMIT clause if not already present."""
        import sqlglot
        from sqlglot import exp

        try:
            config = get_dialect_config(self.dialect)
            ast = sqlglot.parse_one(sql, read=config.sqlglot_dialect)

            # Check if LIMIT already exists
            if ast.find(exp.Limit):
                return sql

            # Add LIMIT
            sql = sql.rstrip(";").strip()
            return f"{sql} LIMIT {limit}"

        except Exception:
            # Fallback: simple string check
            if "limit" not in sql.lower():
                sql = sql.rstrip(";").strip()
                return f"{sql} LIMIT {limit}"
            return sql

    def process_query(
        self,
        sql: str,
        validate: bool = None,
        verbose: bool = False
    ) -> ExecutorResult:
        """
        Full evaluation pipeline: validate -> execute -> analyze.

        This is the main entry point for evaluating SQL queries.

        Args:
            sql: SQL query to evaluate
            validate: Override validation setting (default from config)
            verbose: Print progress information

        Returns:
            ExecutorResult with validation, execution, and analysis results
        """
        validate = validate if validate is not None else self.config.validate_before_execute

        result = ExecutorResult(
            query=sql,
            dialect=self.dialect,
        )

        # Extract query metadata for scoring
        parsed = self.parser.parse(sql, self.dialect)
        tables_accessed = parsed.identifiers.tables
        columns_accessed = parsed.identifiers.columns

        # Step 1: Validation
        if validate:
            if verbose:
                print(f"Validating query for {self.dialect}...")

            validation = self.validate_query(sql)
            result.validation = {
                "is_valid": validation.is_valid,
                "errors": validation.errors,
                "warnings": validation.warnings,
                "query_type": parsed.query_type,
                "tables_accessed": tables_accessed,
                "columns_accessed": columns_accessed,
                "hallucination_report": (
                    validation.hallucination_report.to_dict()
                    if validation.hallucination_report else None
                ),
            }

            if not validation.is_valid:
                if verbose:
                    print(f"Validation failed: {validation.errors}")
                result.overall_status = "FAILED"
                return result
        else:
            # No validation, still extract metadata
            result.validation = {
                "is_valid": True,
                "errors": [],
                "warnings": [],
                "query_type": parsed.query_type,
                "tables_accessed": tables_accessed,
                "columns_accessed": columns_accessed,
            }

        # Step 2: Execution
        if verbose:
            print(f"Executing query...")

        execution = self.execute_query(sql)
        result.execution = execution

        if not execution["success"]:
            if verbose:
                print(f"Execution failed: {execution.get('error')}")
            result.overall_status = "FAILED"
            return result

        # Step 3: Analysis
        result.analysis = self._analyze_results(execution)

        if verbose:
            print(f"Success! Returned {execution['rows_returned']} rows")

        result.overall_status = "SUCCESS"
        return result

    def _analyze_results(self, execution: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze execution results for insights."""
        analysis = {
            "insights": [],
            "summary": "",
        }

        rows = execution.get("rows_returned", 0)
        time_ms = execution.get("execution_time_ms", 0)

        # Generate insights
        if rows == 0:
            analysis["insights"].append("Query returned no results")
        elif rows == self.config.row_limit:
            analysis["insights"].append(
                f"Results may be truncated (limit: {self.config.row_limit})"
            )

        if time_ms > 1000:
            analysis["insights"].append(
                f"Query took {time_ms:.0f}ms - consider optimization"
            )

        # Generate summary
        analysis["summary"] = (
            f"Returned {rows} rows in {time_ms:.2f}ms"
        )

        return analysis

    def get_schema_info(self) -> Dict[str, Any]:
        """Get schema information as a dictionary."""
        return self.schema.to_dict()

    def get_table_info(self, table_name: str) -> Optional[Dict[str, Any]]:
        """Get information about a specific table."""
        table = self.schema.get_table(table_name)
        return table.to_dict() if table else None

    def list_tables(self) -> List[str]:
        """List all tables in the database."""
        return self.schema.table_names

    def close(self) -> None:
        """Close the database connection."""
        self.adapter.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

def create_sqlite_executor(db_path: str = ":memory:") -> SQLExecutor:
    """
    Create a SQLite executor.

    Args:
        db_path: Path to SQLite database, or ":memory:" for in-memory

    Returns:
        Configured SQLExecutor instance
    """
    return SQLExecutor(ExecutorConfig(
        dialect="sqlite",
        db_path=db_path,
    ))


def create_duckdb_executor(db_path: str = ":memory:") -> SQLExecutor:
    """
    Create a DuckDB executor.

    Args:
        db_path: Path to DuckDB database, or ":memory:" for in-memory

    Returns:
        Configured SQLExecutor instance
    """
    return SQLExecutor(ExecutorConfig(
        dialect="duckdb",
        db_path=db_path,
    ))


def create_postgresql_executor(connection_string: str) -> SQLExecutor:
    """
    Create a PostgreSQL executor.

    Args:
        connection_string: PostgreSQL connection string

    Returns:
        Configured SQLExecutor instance
    """
    return SQLExecutor(ExecutorConfig(
        dialect="postgresql",
        connection_string=connection_string,
    ))
